# Bézier ホモトピーの中間制御点を PPO で最適化する設計案（1変数→多変数へ拡張可能）

## 0. 目的
- 目的多項式系（ターゲット）を **F**，開始多項式系を **G** とする．
- 係数空間上で **G から F へ向かうホモトピーパス**を定義し，そのパス上でホモトピー連続法（HC）の経路追跡を行う．
- パスの形（Bézier 曲線の中間制御点）を **強化学習（PPO）**で最適化し，
  - 追跡の成功率を上げる
  - Newton 反復回数やステップ数を減らす
  - 可能なら計算時間も減らす
  ことを狙う．
- 学習後は，多数のペア $(G_i,F_i)$ を用意し，各ペアに対して
  - 線形パス（$G_i\to F_i$）＋ $\gamma$ trick
  - Bézier パス（PPO が中間制御点を構成）
  を同一条件で solver にかけ，速度・成功率などを比較する．再現性を重視する．

---

## 1. 多項式と係数ベクトルの表現（複素係数）
### 1.1 1変数・次数上限
- 1変数を **x** とする．
- 次数上限を **n**（例：10 あるいは 20）とする．
- サポート固定（次数 0 から n まで全て使う）を前提にする．

このとき，多項式 **h**（h は $F$ や $G$ を構成する各方程式，あるいは中間制御点に対応する多項式）は
$$
h(x)=\sum_{j=0}^{n} c_j x^j
$$
で表される．ここで，
- $c_j$ は **複素係数**（$c_j\in\mathbb{C}$）．
- 係数の個数は $D=n+1$ 個である．

### 1.2 複素係数を実ベクトルに変換
強化学習の連続 action を扱いやすくするため，複素係数を実数のベクトルに変換する．

- 係数ベクトルを
$$
c(h)=(c_0,c_1,\dots,c_n)^\top\in\mathbb{C}^{D}
$$
と書く（$\top$ は転置）．
- 実ベクトル化（実部と虚部を縦に連結）を
$$
\tilde c(h)=
\begin{bmatrix}
\Re c(h) \\
\Im c(h)
\end{bmatrix}
\in\mathbb{R}^{2D}
$$
と定義する．
  - $\Re$ は実部，$\Im$ は虚部．
  - これで「複素 $D$ 次元」を「実 $2D$ 次元」に変換できる．

具体例：
- $n=10$ のとき $D=11$，$\tilde c(h)\in\mathbb{R}^{22}$．
- $n=20$ のとき $D=21$，$\tilde c(h)\in\mathbb{R}^{42}$．

## 1.3 開始多項式系 $G$ の生成（total-degree start system）
本研究では，開始多項式系 $G$ は **多変数の total-degree start system** により構成する．

- 変数の個数を $n_{\mathrm{var}}$ とする．
- 目的多項式系 $F$ は $n_{\mathrm{eq}}$ 本の多項式からなり，各方程式を $f_i$ と書く（$i=1,\dots,n_{\mathrm{eq}}$）．
- 各方程式 $f_i$ の（全）次数を $d_i$ とする（$d_i$ は正の整数）．

このとき，total-degree start system は次で定義する：
$$
g_i(x_1,\dots,x_{n_{\mathrm{var}}}) = x_i^{d_i} - 1 \quad (i=1,\dots,n_{\mathrm{eq}})
$$
ここで，
- $x_1,\dots,x_{n_{\mathrm{var}}}$ は変数である．
- 開始多項式系 $G$ は $G=\{g_1,\dots,g_{n_{\mathrm{eq}}}\}$ として与える．

$G$ の解は既知である．実際，それぞれの $g_i=0$ は $d_i$ 個の $d_i$ 乗根を持つため，$G=0$ の解はそれらの直積として与えられる（したがって開始解集合を明示的に列挙できる）．

注記：
- 1変数実験を行う場合も，上式を $n_{\mathrm{var}}=1$，$n_{\mathrm{eq}}=1$ とみなせば $g_1(x)=x^{d_1}-1$ となり，従来の「$x^n-1$ を開始系にする」選択と整合する．
- 将来的に多変数へ拡張する際も，同一の規則で $G$ を生成できるため，設計の一貫性が保たれる．

---

## 2. Bézier 曲線で係数空間のパスを作る
### 2.1 Bézier degree と制御点
- Bézier degree を **d** とする（例：2 または 3）．
- 制御点を $P_0,P_1,\dots,P_d$ とする．
  - $P_0$ は開始点，$P_d$ は終点である．
  - 中間制御点は $P_1,\dots,P_{d-1}$ で，ここを最適化対象にする．

### 2.2 $\gamma$ trick（複素定数による一般位置化）
$\gamma$ を
- $\gamma\in\mathbb{C}$
- $|\gamma|=1$（絶対値 1）
とする．

制御点の端点を
- $P_0=\gamma G$
- $P_d=F$
とする．

注意：
- $\gamma$ は **同じエピソード内部では固定**するのが推奨（途中で変えると報酬の意味が崩れる）．
- 再現性のため，評価用データセットでは各ペア $(G_i,F_i)$ ごとに $\gamma_i$ を一つ決め打ちし保存する（後述）．

---

## 3. 基準点（線分）と中間制御点のパラメータ化
### 3.1 線分上の基準点 $\bar P_k$
中間制御点の「基準」として，線形補間を用いる．

中間インデックスを $k\in\{1,2,\dots,d-1\}$ とする．
このとき基準点 $\bar P_k$ を
$$
\bar P_k=\left(1-\frac{k}{d}\right)(\gamma G)+\frac{k}{d}F
$$
で定義する．

ここで，
- $\frac{k}{d}$ は 0 から 1 への進行度．
- $\bar P_k$ は「線形ホモトピー上の自然な位置」である．

### 3.2 潜在変数方式：$\bar P_k$ からの低次元摂動
**潜在変数方式**とは，
- 中間制御点 $P_k$ を高次元（係数空間）で直接出すのではなく，
- 低次元ベクトルを action として出し，
- 固定の写像で高次元の摂動に変換する
という方法である．

#### (a) 潜在変数 $z_k$
- $z_k\in\mathbb{R}^{m}$ を潜在変数とする．
- **m は潜在次元**であり，「エージェントが動かせる自由度の数」を表す．
  - m が大きいほど表現力が上がるが探索が難しくなる．
  - 多変数へ拡張したとき係数次元が爆発しても，m を固定すれば action 次元を固定できる．

#### (b) 基底（固定変換）$U$
- $U\in\mathbb{R}^{2D\times m}$ を固定行列とする．
- $U$ の各列は「係数空間（実 $2D$ 次元）で動かしてよい方向」を表す．

#### (c) 摂動 $Uz_k$
- $Uz_k\in\mathbb{R}^{2D}$ は摂動ベクトルであり，
$$
Uz_k=z_{k,1}u_1+z_{k,2}u_2+\cdots+z_{k,m}u_m
$$
のように，$U$ の列ベクトル $u_1,\dots,u_m$ の線形結合として解釈できる．

#### (d) 中間制御点 $P_k$ の定義
複素係数を実ベクトル化した表現 $\tilde c(\cdot)$ を使い，
$$
\tilde c(P_k)=\tilde c(\bar P_k)+Uz_k
$$
で中間制御点を定義する．

- 右辺は $\mathbb{R}^{2D}$ の式になっているので整合的．
- $\tilde c(P_k)$ から複素係数に戻せば $P_k$（多項式としての制御点）を得られる．

#### (e) $U$ の作り方（実装が簡単な選択）
- 最初は $U$ を **学習せず固定**にする．
- 例：ランダム行列を作って QR 分解で列直交にし，上位 m 列を採用する．
  - 列直交だと $\|Uz\|$ と $\|z\|$ の関係が単純になり，クリップ設計が楽．

---

## 4. Action の具体形とエピソード設計（one-step / multi-step）
本章では，Bézier degree $d$ が小さい場合（例：$d=2$ または $d=3$）に，action をどのように定義し，1エピソード内で何回 solver を走らせるかを整理する．
ここで「ステップ」とは，エージェントが action を出力し，その action に基づいて Bézier パスを評価するために solver を1回実行する単位を指す．

### 4.1 one-step 設計（1回行動して終了）
- 1エピソードにつき，問題インスタンス $(G,F,\gamma)$ を1つ固定する．
- エージェントは1回だけ action を出し，中間制御点の系列を一括で決める．
  - action は潜在変数で
    $$
    \mathbf{a}=(z_1,\dots,z_{d-1})\in\mathbb{R}^{(d-1)m}
    $$
    とし，$z_k\in\mathbb{R}^m$ は中間制御点 $P_k$ の潜在変数である．
- 潜在変数から中間制御点を
  $$
  \tilde c(P_k)=\tilde c(\bar P_k)+Uz_k \quad (k=1,\dots,d-1)
  $$
  で構成し，Bézier パスを確定する．
- solver を1回だけ走らせて報酬を得てエピソード終了とする．

注記：
- one-step は設計が単純で，評価プロトコル（多数の $(G_i,F_i,\gamma_i)$ に対して1本の Bézier パスを作る）と整合しやすい．

#### 4.1.1 $d=2$ の場合
- 中間制御点は1個（$P_1$）である．
- action は
  $$
  \mathbf{a}=z_1\in\mathbb{R}^{m}
  $$
  として一括で出力する．

#### 4.1.2 $d=3$ の場合
- 中間制御点は2個（$P_1,P_2$）である．
- action は
  $$
  \mathbf{a}=(z_1,z_2)\in\mathbb{R}^{2m}
  $$
  を一括で出力する．

---

### 4.2 multi-step 設計（エピソード内で複数回改良）
一変数の低次数では solver が高速に動くため，1エピソード内で複数回 solver を実行し，段階的に中間制御点を改良する multi-step 設計も採用できる．

- 1エピソードにつき，問題インスタンス $(G,F,\gamma)$ を固定し，反復回数 $T$ を決める（例：$T=4$ または $T=8$）．
- 時刻 $i=0,1,\dots,T-1$ において，action を「潜在変数の増分」として
  $$
  \mathbf{a}^{(i)}=(\Delta z_1^{(i)},\dots,\Delta z_{d-1}^{(i)})\in\mathbb{R}^{(d-1)m}
  $$
  のように出力する．ここで $\Delta z_k^{(i)}\in\mathbb{R}^m$ である．
- 潜在変数を
  $$
  z_k^{(i+1)}=\mathrm{clip}\!\left(z_k^{(i)}+\Delta z_k^{(i)},\alpha\right)
  $$
  で更新する．ここで $\alpha>0$ は上限であり，$\mathrm{clip}$ は例えば $\|z_k^{(i+1)}\|\le\alpha$ を満たすように切り詰める操作を表す．
- 更新された潜在変数 $z_k^{(i)}$ から中間制御点を
  $$
  \tilde c(P_k^{(i)})=\tilde c(\bar P_k)+Uz_k^{(i)}
  $$
  で構成し，solver を走らせて評価値（成功フラグ，#steps，total Newton iters，wall time など）を得る．

注記：
- 実装上は初期値として $z_k^{(0)}=0$ を用いると，再現性と比較が容易になる．

---

### 4.3 報酬設計（one-step と multi-step の統一）
solver は「失敗フラグ」を返すが，失敗時ログ（打ち切りまでの #steps や total Newton iters）が成功時より小さくなる可能性がある．
その場合，失敗を小さなコストとして誤って学習しないように，失敗時は一律で大きな罰を与える．

- 時刻 $i$ における成功フラグを $s^{(i)}\in\{0,1\}$（成功なら 1）とする．
- #steps を $K^{(i)}$，total Newton iters を $N^{(i)}$ とする．
- 1回の solver 実行結果からコスト $J^{(i)}$ を
  $$
  J^{(i)}=
  \begin{cases}
  N^{(i)}+\lambda K^{(i)} & (s^{(i)}=1) \\
  M & (s^{(i)}=0)
  \end{cases}
  $$
  と定義する．ここで $\lambda>0$ は重み，$M$ は失敗時の大きな定数ペナルティである．

#### 4.3.1 one-step の報酬
- one-step の場合は，単一回の評価から
  $$
  r=-J
  $$
  とする（$J$ を小さくするほど報酬が大きくなる）．

#### 4.3.2 multi-step の報酬（差分報酬）
- multi-step の場合は「改善量」に対応させるため，
  $$
  r^{(i)}=J^{(i)}-J^{(i+1)}
  $$
  のような差分報酬を用いる．これにより，エピソード内でコストが減る（改善する）ほど正の報酬が得られる．

注記：
- $\gamma$ はエピソード内では固定し，評価では各ペア $(G_i,F_i)$ ごとに $\gamma_i$ を決め打ちして保存する方針と整合する．



---

## 5. State（観測）設計と正規化
### 5.1 State に含める情報（標準案）
- 目的多項式系 $F$ を構成する各多項式 $f$ について，実ベクトル化係数 $\tilde c(f)\in\mathbb{R}^{2D}$ を用いる．実装上は，それらを連結して state を作る．
- 開始多項式系 $G$ を構成する各多項式 $g$ について，実ベクトル化係数 $\tilde c(g)\in\mathbb{R}^{2D}$ を用いる（実装を単純にするため state に含める）．
- $\gamma$ の実部・虚部 $(\Re\gamma,\Im\gamma)\in\mathbb{R}^2$（エピソード内固定だが，エピソード間で変えるので情報として入れる）．
- メタ情報として次数上限 $n$ と Bézier degree $d$（整数）．

### 5.2 係数ベクトルの正規化（推奨）
係数のスケールがエピソードごとに変わると学習が不安定になり得るため，state の係数部分は正規化する．

- 正規化対象：state に含めた各係数ベクトル $\tilde c(f)$ と $\tilde c(g)$ の各成分．
- 方法：学習中に running mean と running variance を更新し，各成分を標準化する（例：$(x-\mu)/\sigma$ 形式）．

ただし，係数を標準化すると「絶対スケール情報」が弱くなる可能性があるため，追加のスカラー特徴として
- $\log\|\tilde c(f)\|$
- $\log\|\tilde c(g)\|$
を state に入れる案がある（$\|\cdot\|$ はユークリッドノルム）．

---

## 6. 暴走防止（重要：solver を壊しにくくする）
摂動が大きいと係数が極端になり，HC ソルバーが失敗しやすい．
そこで少なくとも次のいずれかを入れる：

- 潜在変数のノルム制限：$\|z_k\|\le\alpha$（$\alpha$ は上限値）．
- 摂動のノルム制限：$\|Uz_k\|\le\beta$（$\beta$ は上限値）．
- 係数ノルムの罰則：$\|\tilde c(P_k)\|$ を大きくしすぎないよう reward に罰則を入れる．

---

## 7. Reward の候補（Julia HC ソルバーで計測）
エピソードごとに Julia の HC ソルバーを走らせて統計量を得る．例：

- 成功・失敗のフラグ（成功なら 1，失敗なら 0）
- Newton 反復回数の合計
- predictor–corrector のステップ数
- wall time（可能なら）

報酬の例：
- 成功ボーナスを与えつつ，反復回数やステップ数を減らす方向に学習させる．
- wall time はノイズが入りやすいので，反復回数やステップ数を主に使い，補助的に時間を入れる方針もある．

---

## 8. 再現性重視の評価プロトコル（$(G_i,F_i)$ と $\gamma_i$ の保存）
学習後の比較実験で再現性を担保するため，以下を採用する：

- 評価用に多数のペア $(G_i,F_i)$ を作成し保存する．
- 各ペア $(G_i,F_i)$ ごとに，$\gamma_i$ を一つ決め打ちして保存する（$|\gamma_i|=1$）．
- 比較では，同じ $(G_i,F_i,\gamma_i)$ に対して
  - 線形パス（$G_i\to F_i$）＋ $\gamma_i$
  - PPO が構成した Bézier パス（端点は $P_0=\gamma_i G_i$，$P_d=F_i$）
  を solver にかけ，成功率や計算コストを比較する．

注意：
- 線形パスと Bézier パスで solver の設定（許容誤差，最大ステップなど）を揃える．
- Julia の JIT の影響があるため，評価前にウォームアップを入れ，測定はウォームアップ後に行う．

## 8.1 $(G_i,F_i,\gamma_i)$ の生成と保存（再現性）
評価では多数の問題インスタンスを用意し，線形パスと Bézier パスを同一条件で比較する．そのため，各インスタンスごとに $(G_i,F_i,\gamma_i)$ を保存する．

- 各インスタンス $i$ に対して，目的多項式系を $F_i=\{f_{i,1},\dots,f_{i,n_{\mathrm{eq}}}\}$ として生成し保存する（係数や乱数 seed も必要なら保存する）．
- $F_i$ の次数情報から $(d_1,\dots,d_{n_{\mathrm{eq}}})$ を決め，対応する total-degree start system を
$$
g_{i,j}(x_1,\dots,x_{n_{\mathrm{var}}}) = x_j^{d_j} - 1 \quad (j=1,\dots,n_{\mathrm{eq}})
$$
として構成し，開始多項式系 $G_i=\{g_{i,1},\dots,g_{i,n_{\mathrm{eq}}}\}$ を保存する．
- $\gamma_i\in\mathbb{C}$ を $|\gamma_i|=1$ となるように一つ決め打ちし保存する（例：$\gamma_i=\exp(\mathrm{i}\theta_i)$ として角度 $\theta_i$ を保存する）．

- 比較では，同じ $(G_i,F_i,\gamma_i)$ に対して
  - 線形パス（$G_i\to F_i$）＋ $\gamma_i$
  - PPO が構成した Bézier パス（端点は $P_0=\gamma_i G_i$，$P_d=F_i$）
    （この Bézier パスは，各 $i$ ごとに PPO が中間制御点を出力して構成する）
  を solver にかけ，成功率や計算コストを比較する．

---

## 9. サポート固定 vs 可変のメモ
- 1変数で次数上限まで全項を含めるなら，サポート固定は自然で実装も簡単．
- 多変数へ拡張すると「可変サポート」は離散選択（どの単項式を採用するか）を含み，PPO の設計が難しくなる．
- まずはサポート固定＋潜在変数方式で回し，必要になってから可変サポート（離散＋連続の混合 action）を検討するのが現実的．

---

## 10. まとめ（設計の核）
- 係数は複素数なので，実部・虚部に分解して $\mathbb{R}^{2D}$ 上で制御する．
- Bézier degree は $d=2$ or 3 とし，中間制御点を一括更新する．
- 中間制御点は「線分上の基準点」$\bar P_k$ に「低次元摂動」$Uz_k$ を足して表現する．
- m は潜在次元であり，action 次元を小さく保つための重要なハイパーパラメータである．
- $\gamma$ trick（$|\gamma|=1$ の複素定数）は $P_0=\gamma G$ として取り入れてよい．同じエピソード内では固定し，評価では各ペア $(G_i,F_i)$ ごとに $\gamma_i$ を決め打ちして保存する方針とする．
- state の係数部分（各 $\tilde c(f)$，各 $\tilde c(g)$）は正規化し，必要なら $\log\|\tilde c(f)\|$，$\log\|\tilde c(g)\|$ を追加してスケール情報も保持する．
